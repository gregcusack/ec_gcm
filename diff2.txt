diff --git a/Manager.cpp b/Manager.cpp
index f4d8db7..07ed67e 100644
--- a/Manager.cpp
+++ b/Manager.cpp
@@ -27,230 +27,230 @@ void ec::Manager::start(const std::string &app_name, const std::vector<std::stri
     application_thread.join();
     event_handler_thread.join();
 }
-/*
-int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
-
-    if(req == nullptr || res == nullptr) {
-        std::cout << "req or res == null in handle_cpu_usage_report()" << std::endl;
-        exit(EXIT_FAILURE);
-    }
-//    return __ALLOC_SUCCESS__;
-    if(req->req_type != _CPU_) { return __ALLOC_FAILED__; }
 
-    auto t1 = std::chrono::high_resolution_clock::now();
-    cpulock.lock();
-//    std::cout << "--------------IN: " << req->cgroup_id << "----------------" << std::endl;
-//    std::cout << "cg id: " << req->cgroup_id << std::endl;
-    auto sc_id = SubContainer::ContainerId(req->cgroup_id, req->client_ip);
-    auto sc = ec_get_sc_for_update(sc_id);
-    if(!sc) {
-        std::cout << "ERROR! sc is NULL!" << std::endl;
-        return __ALLOC_SUCCESS__;
-    }
-    sc->incr_counter();
-    auto req_count = sc->get_counter();
-    auto rx_quota = req->rsrc_amnt;
-    auto rt_remaining = req->runtime_remaining;
-    auto throttled = req->request;
-    uint64_t updated_quota = rx_quota;
-    uint64_t to_add = 0;
-    int ret;
-    uint64_t rx_buff;
-    double thr_mean = 0;
-    uint64_t rt_mean = 0;
-    uint64_t total_rt = 0;
-    int64_t unalloc_rt = 0;
-
-    for(const auto &i : get_subcontainers()) {
-//        std::cout << "alloc per cont (" << i.second->get_c_id()->cgroup_id << "): " << i.second->sc_get_quota() << std::endl;
-        total_rt += i.second->sc_get_quota();
-    }
-
-    unalloc_rt = ec_get_total_cpu() - total_rt;
-    if(unalloc_rt < 0) {
-        ec_set_overrun(total_rt - ec_get_total_cpu());
-        unalloc_rt = 0;
-    }
-    ec_set_unallocated_rt(unalloc_rt);
-
-//    if(total_rt - ec_get_total_cpu() > 0) {
+//int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
 //
+//    if(req == nullptr || res == nullptr) {
+//        std::cout << "req or res == null in handle_cpu_usage_report()" << std::endl;
+//        exit(EXIT_FAILURE);
 //    }
-
-//    total_rt += ec_get_cpu_unallocated_rt();
-//    std::cout << "total rt: " << total_rt << std::endl;
-//    if(ec_get_fair_cpu_share() * get_subcontainers().size() < total_rt) {
-//        std::cout << "WOOPS! ALLOC TOO MUCH CPU!" << std::endl;
+////    return __ALLOC_SUCCESS__;
+//    if(req->req_type != _CPU_) { return __ALLOC_FAILED__; }
+//
+//    auto t1 = std::chrono::high_resolution_clock::now();
+//    cpulock.lock();
+////    std::cout << "--------------IN: " << req->cgroup_id << "----------------" << std::endl;
+////    std::cout << "cg id: " << req->cgroup_id << std::endl;
+//    auto sc_id = SubContainer::ContainerId(req->cgroup_id, req->client_ip);
+//    auto sc = ec_get_sc_for_update(sc_id);
+//    if(!sc) {
+//        std::cout << "ERROR! sc is NULL!" << std::endl;
+//        return __ALLOC_SUCCESS__;
 //    }
-
-//    std::cout << "quota, rt_remaining, throttled): (" << rx_quota << ", " << rt_remaining << ", " << throttled << ")" << std::endl;
-//    //TODO: when we change quota, we need to flush the window
-//    if(likely(!sc->get_set_quota_flag())) {
-//        rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
-//        thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
-//    } else {
-//        rt_mean = sc->get_cpu_stats()->get_rt_mean();
-//        thr_mean = sc->get_cpu_stats()->get_thr_mean();
-//        sc->set_quota_flag(false);
+//    sc->incr_counter();
+//    auto req_count = sc->get_counter();
+//    auto rx_quota = req->rsrc_amnt;
+//    auto rt_remaining = req->runtime_remaining;
+//    auto throttled = req->request;
+//    uint64_t updated_quota = rx_quota;
+//    uint64_t to_add = 0;
+//    int ret;
+//    uint64_t rx_buff;
+//    double thr_mean = 0;
+//    uint64_t rt_mean = 0;
+//    uint64_t total_rt = 0;
+//    int64_t unalloc_rt = 0;
+//
+//    for(const auto &i : get_subcontainers()) {
+////        std::cout << "alloc per cont (" << i.second->get_c_id()->cgroup_id << "): " << i.second->sc_get_quota() << std::endl;
+//        total_rt += i.second->sc_get_quota();
 //    }
-    rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
-    thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
-//    std::cout << "rt_mean: " << rt_mean << std::endl;
-//    std::cout << "thr_mean: " << thr_mean << std::endl;
-    std::cout << "cpu_unalloc: " << ec_get_cpu_unallocated_rt() << std::endl;
-//    std::cout << "total alloced: " << total_rt << std::endl;
-//    std::cout << "sys thinks cpu: " << ec_get_cpu_unallocated_rt() + total_rt << std::endl;
-//    std::cout << "sys should hav: " << ec_get_total_cpu() << std::endl;
 //
-//    if(ec_get_cpu_unallocated_rt() + total_rt != ec_get_total_cpu()) {
-//        std::cout << "[ERROR]: CPU ALLOC MISMATCH" << std::endl;
-////        std::cout << "sys thinks cpu: " << ec_get_cpu_unallocated_rt() + total_rt << std::endl;
-////        std::cout << "sys should hav: " << ec_get_total_cpu() << std::endl;
+//    unalloc_rt = ec_get_total_cpu() - total_rt;
+//    if(unalloc_rt < 0) {
+//        ec_set_overrun(total_rt - ec_get_total_cpu());
+//        unalloc_rt = 0;
 //    }
-
-    if(ec_get_overrun() > 0 && rx_quota > ec_get_fair_cpu_share()) {
-        std::cout << "overrun. sc: " << *sc->get_c_id() << std::endl;
-        uint64_t to_sub;
-        uint64_t amnt_share_over = rx_quota - ec_get_fair_cpu_share();
-        uint64_t overrun = ec_get_overrun();
-        double percent_over = ((double)rx_quota - (double)ec_get_fair_cpu_share()) / (double)ec_get_fair_cpu_share();
-//        std::cout << "percent over: " << percent_over << std::endl;
-        if(percent_over > 1) {
-            to_sub = (uint64_t) (percent_over * (double) ec_get_cpu_slice());
-        }
-        else {
-            to_sub = (uint64_t) (percent_over * (double)amnt_share_over);
-        }
-        //TODO: thr_mean is probably important. Take less from containers that are constantly being throttled
-//        uint64_t to_sub_frac = (1 - thr_mean) * amnt_share_over;
-        if(to_sub < ec_get_cpu_slice() / 2) { //ensures we eventually converge
-            to_sub = amnt_share_over;
-        }
-        to_sub = std::min(overrun, to_sub);
-        updated_quota = rx_quota - to_sub;
-        ret = set_sc_quota(sc, updated_quota);
-        if(ret < 0) {
-            std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (overrun sub quota). ret: " << ret << std::endl;
-        }
-        else {
-            sc->set_quota_flag(true);
-            std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
-        }
-        sc->get_cpu_stats()->flush();
-        ec_decr_overrun(to_sub);
-        sc->sc_set_quota(updated_quota);
-    }
-    else if(rx_quota < ec_get_fair_cpu_share() && thr_mean > 0.5) {   //throttled but don't have fair share
-//        std::cout << "throt and less than fair share. sc: " << *sc->get_c_id() << std::endl;
-        uint64_t amnt_share_lacking = ec_get_fair_cpu_share() - rx_quota;
-//        std::cout << "amnt_share_lacking: " << amnt_share_lacking << std::endl;
-        if (ec_get_cpu_unallocated_rt() > 0) {
-            //TODO: take min of to_Add and slice. don't full reset
-//            std::cout << "give back some unalloc_Rt. sc: " << *sc->get_c_id() << std::endl;
-            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
-            std::cout << "percent under1: " << percent_under << std::endl;
-            if(amnt_share_lacking > ec_get_cpu_slice() / 2) {   //ensure we eventually converge
-                to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(percent_under * (double)amnt_share_lacking));
-            }
-            else {
-                to_add = amnt_share_lacking;
-            }
-//            to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(thr_mean * amnt_share_lacking));
-//            std::cout << "to_Add: " << to_add << std::endl;
-            updated_quota = rx_quota + to_add;
-            ret = set_sc_quota(sc, updated_quota);
-            if(ret < 0) {
-                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share). ret: " << ret << std::endl;
-            }
-            else {
-                sc->set_quota_flag(true);
-                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
-            }
-            ec_decr_unallocated_rt(to_add);
-            sc->sc_set_quota(updated_quota);
-//            std::cout << "new_quota: " << updated_quota << std::endl;
-//            std::cout << "ec_get_unalloc_rt: " << ec_get_cpu_unallocated_rt() << std::endl;
-        }
-        else { //not enough in unalloc_rt to get back to fair share, even out
-//            std::cout << "not enough in unalloc rt. give back slice or overrun.. sc: " << *sc->get_c_id() << std::endl;
-            uint64_t overrun;
-            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
-//            std::cout << "percent under2: " << percent_under << std::endl;
-//            overrun = (uint64_t)thr_mean * amnt_share_lacking;
-            if(amnt_share_lacking > ec_get_cpu_slice() / 2) { //ensure we eventualyl converge
-                overrun = (uint64_t)((double) percent_under * amnt_share_lacking);
-            }
-            else {
-                overrun = amnt_share_lacking;
-            }
-            updated_quota = rx_quota + overrun;
-            ret = set_sc_quota(sc, updated_quota);
-            if(ret < 0) {
-                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share overrun). ret: " << ret << std::endl;
-            }
-            else {
-                sc->set_quota_flag(true);
-                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
-            }
-            ec_incr_overrun(overrun);
-            sc->sc_set_quota(updated_quota);
-        }
-        sc->get_cpu_stats()->flush();
-    }
-    else if(thr_mean >= 0.2 && ec_get_cpu_unallocated_rt() > 0) {  //sc_quota > fair share and container got throttled during the last period. need rt
-//        std::cout << "throttle. try get alloc. sc:  " << *sc->get_c_id() << std::endl;
-        auto extra_rt = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(2 * thr_mean * ec_get_cpu_slice()));
-//        std::cout << "extra_rt: " << extra_rt << std::endl;
-        if(extra_rt > 0) {
-            ec_decr_unallocated_rt(extra_rt);
-            updated_quota = rx_quota + extra_rt;
-            ret = set_sc_quota(sc, updated_quota);
-            if(ret < 0) {
-                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr). ret: " << ret << std::endl;
-            }
-            else {
-                sc->set_quota_flag(true);
-                std::cout << "successfully resized quota to (incr): " << rx_quota + extra_rt << "!" << std::endl;
-            }
-        }
+//    ec_set_unallocated_rt(unalloc_rt);
+//
+////    if(total_rt - ec_get_total_cpu() > 0) {
+////
+////    }
+//
+////    total_rt += ec_get_cpu_unallocated_rt();
+////    std::cout << "total rt: " << total_rt << std::endl;
+////    if(ec_get_fair_cpu_share() * get_subcontainers().size() < total_rt) {
+////        std::cout << "WOOPS! ALLOC TOO MUCH CPU!" << std::endl;
+////    }
+//
+////    std::cout << "quota, rt_remaining, throttled): (" << rx_quota << ", " << rt_remaining << ", " << throttled << ")" << std::endl;
+////    //TODO: when we change quota, we need to flush the window
+////    if(likely(!sc->get_set_quota_flag())) {
+////        rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
+////        thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
+////    } else {
+////        rt_mean = sc->get_cpu_stats()->get_rt_mean();
+////        thr_mean = sc->get_cpu_stats()->get_thr_mean();
+////        sc->set_quota_flag(false);
+////    }
+//    rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
+//    thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
+////    std::cout << "rt_mean: " << rt_mean << std::endl;
+////    std::cout << "thr_mean: " << thr_mean << std::endl;
+//    std::cout << "cpu_unalloc: " << ec_get_cpu_unallocated_rt() << std::endl;
+////    std::cout << "total alloced: " << total_rt << std::endl;
+////    std::cout << "sys thinks cpu: " << ec_get_cpu_unallocated_rt() + total_rt << std::endl;
+////    std::cout << "sys should hav: " << ec_get_total_cpu() << std::endl;
+////
+////    if(ec_get_cpu_unallocated_rt() + total_rt != ec_get_total_cpu()) {
+////        std::cout << "[ERROR]: CPU ALLOC MISMATCH" << std::endl;
+//////        std::cout << "sys thinks cpu: " << ec_get_cpu_unallocated_rt() + total_rt << std::endl;
+//////        std::cout << "sys should hav: " << ec_get_total_cpu() << std::endl;
+////    }
+//
+//    if(ec_get_overrun() > 0 && rx_quota > ec_get_fair_cpu_share()) {
+//        std::cout << "overrun. sc: " << *sc->get_c_id() << std::endl;
+//        uint64_t to_sub;
+//        uint64_t amnt_share_over = rx_quota - ec_get_fair_cpu_share();
+//        uint64_t overrun = ec_get_overrun();
+//        double percent_over = ((double)rx_quota - (double)ec_get_fair_cpu_share()) / (double)ec_get_fair_cpu_share();
+////        std::cout << "percent over: " << percent_over << std::endl;
+//        if(percent_over > 1) {
+//            to_sub = (uint64_t) (percent_over * (double) ec_get_cpu_slice());
+//        }
 //        else {
-//            std::cout << "extra_rt == 0: " << extra_rt << std::endl;
+//            to_sub = (uint64_t) (percent_over * (double)amnt_share_over);
+//        }
+//        //TODO: thr_mean is probably important. Take less from containers that are constantly being throttled
+////        uint64_t to_sub_frac = (1 - thr_mean) * amnt_share_over;
+//        if(to_sub < ec_get_cpu_slice() / 2) { //ensures we eventually converge
+//            to_sub = amnt_share_over;
+//        }
+//        to_sub = std::min(overrun, to_sub);
+//        updated_quota = rx_quota - to_sub;
+//        ret = set_sc_quota(sc, updated_quota);
+//        if(ret < 0) {
+//            std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (overrun sub quota). ret: " << ret << std::endl;
 //        }
-        sc->sc_set_quota(updated_quota);
-        sc->get_cpu_stats()->flush();
-    }
-    else if(rt_mean > rx_quota * 0.2) { //greater than 20% of quota unused
-//        std::cout << "rt_mean > 20% of quota. sc: " << *sc->get_c_id() << std::endl;
-        uint64_t new_quota = rx_quota * (1 - 0.2); //sc_quota - sc_rt_remaining + ec_get_cpu_slice();
-        new_quota = std::max(ec_get_cpu_slice(), new_quota);
-        if(new_quota != rx_quota) {
-//            std::cout << "new, old, rt_remain: (" << new_quota << "," << rx_quota << "," << rt_mean << ")" << std::endl;
-            ret = set_sc_quota(sc, new_quota); //give back what was used + 5ms
-            if(ret < 0) {
-                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (decr). ret: " << ret << std::endl;
-            }
-            else {
-                sc->set_quota_flag(true);
-                std::cout << "successfully resized quota to (decr): " << new_quota << "!" << std::endl;
-            }
-//            std::cout << "old quota, new quota: (" << rx_quota << ", " << new_quota << ")" << std::endl;
-            ec_incr_unallocated_rt(rx_quota - new_quota); //unalloc_rt <-- old quota - new quota
-            sc->sc_set_quota(new_quota);
-            sc->get_cpu_stats()->flush();
-        }
 //        else {
-//            std::cout << "new_quota == old_quota: " << new_quota << std::endl;
+//            sc->set_quota_flag(true);
+//            std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
 //        }
-    }
-//    else {
-//        std::cout << "DO NOTHING" << std::endl;
+//        sc->get_cpu_stats()->flush();
+//        ec_decr_overrun(to_sub);
+//        sc->sc_set_quota(updated_quota);
 //    }
-//    std::cout << "--------------OUT:" << req->cgroup_id << "----------------" << std::endl;
-    cpulock.unlock();
-    return __ALLOC_SUCCESS__;
+//    else if(rx_quota < ec_get_fair_cpu_share() && thr_mean > 0.5) {   //throttled but don't have fair share
+////        std::cout << "throt and less than fair share. sc: " << *sc->get_c_id() << std::endl;
+//        uint64_t amnt_share_lacking = ec_get_fair_cpu_share() - rx_quota;
+////        std::cout << "amnt_share_lacking: " << amnt_share_lacking << std::endl;
+//        if (ec_get_cpu_unallocated_rt() > 0) {
+//            //TODO: take min of to_Add and slice. don't full reset
+////            std::cout << "give back some unalloc_Rt. sc: " << *sc->get_c_id() << std::endl;
+//            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
+//            std::cout << "percent under1: " << percent_under << std::endl;
+//            if(amnt_share_lacking > ec_get_cpu_slice() / 2) {   //ensure we eventually converge
+//                to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(percent_under * (double)amnt_share_lacking));
+//            }
+//            else {
+//                to_add = amnt_share_lacking;
+//            }
+////            to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(thr_mean * amnt_share_lacking));
+////            std::cout << "to_Add: " << to_add << std::endl;
+//            updated_quota = rx_quota + to_add;
+//            ret = set_sc_quota(sc, updated_quota);
+//            if(ret < 0) {
+//                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share). ret: " << ret << std::endl;
+//            }
+//            else {
+//                sc->set_quota_flag(true);
+//                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
+//            }
+//            ec_decr_unallocated_rt(to_add);
+//            sc->sc_set_quota(updated_quota);
+////            std::cout << "new_quota: " << updated_quota << std::endl;
+////            std::cout << "ec_get_unalloc_rt: " << ec_get_cpu_unallocated_rt() << std::endl;
+//        }
+//        else { //not enough in unalloc_rt to get back to fair share, even out
+////            std::cout << "not enough in unalloc rt. give back slice or overrun.. sc: " << *sc->get_c_id() << std::endl;
+//            uint64_t overrun;
+//            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
+////            std::cout << "percent under2: " << percent_under << std::endl;
+////            overrun = (uint64_t)thr_mean * amnt_share_lacking;
+//            if(amnt_share_lacking > ec_get_cpu_slice() / 2) { //ensure we eventualyl converge
+//                overrun = (uint64_t)((double) percent_under * amnt_share_lacking);
+//            }
+//            else {
+//                overrun = amnt_share_lacking;
+//            }
+//            updated_quota = rx_quota + overrun;
+//            ret = set_sc_quota(sc, updated_quota);
+//            if(ret < 0) {
+//                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share overrun). ret: " << ret << std::endl;
+//            }
+//            else {
+//                sc->set_quota_flag(true);
+//                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
+//            }
+//            ec_incr_overrun(overrun);
+//            sc->sc_set_quota(updated_quota);
+//        }
+//        sc->get_cpu_stats()->flush();
+//    }
+//    else if(thr_mean >= 0.2 && ec_get_cpu_unallocated_rt() > 0) {  //sc_quota > fair share and container got throttled during the last period. need rt
+////        std::cout << "throttle. try get alloc. sc:  " << *sc->get_c_id() << std::endl;
+//        auto extra_rt = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(2 * thr_mean * ec_get_cpu_slice()));
+////        std::cout << "extra_rt: " << extra_rt << std::endl;
+//        if(extra_rt > 0) {
+//            ec_decr_unallocated_rt(extra_rt);
+//            updated_quota = rx_quota + extra_rt;
+//            ret = set_sc_quota(sc, updated_quota);
+//            if(ret < 0) {
+//                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr). ret: " << ret << std::endl;
+//            }
+//            else {
+//                sc->set_quota_flag(true);
+//                std::cout << "successfully resized quota to (incr): " << rx_quota + extra_rt << "!" << std::endl;
+//            }
+//        }
+////        else {
+////            std::cout << "extra_rt == 0: " << extra_rt << std::endl;
+////        }
+//        sc->sc_set_quota(updated_quota);
+//        sc->get_cpu_stats()->flush();
+//    }
+//    else if(rt_mean > rx_quota * 0.2) { //greater than 20% of quota unused
+////        std::cout << "rt_mean > 20% of quota. sc: " << *sc->get_c_id() << std::endl;
+//        uint64_t new_quota = rx_quota * (1 - 0.2); //sc_quota - sc_rt_remaining + ec_get_cpu_slice();
+//        new_quota = std::max(ec_get_cpu_slice(), new_quota);
+//        if(new_quota != rx_quota) {
+////            std::cout << "new, old, rt_remain: (" << new_quota << "," << rx_quota << "," << rt_mean << ")" << std::endl;
+//            ret = set_sc_quota(sc, new_quota); //give back what was used + 5ms
+//            if(ret < 0) {
+//                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (decr). ret: " << ret << std::endl;
+//            }
+//            else {
+//                sc->set_quota_flag(true);
+//                std::cout << "successfully resized quota to (decr): " << new_quota << "!" << std::endl;
+//            }
+////            std::cout << "old quota, new quota: (" << rx_quota << ", " << new_quota << ")" << std::endl;
+//            ec_incr_unallocated_rt(rx_quota - new_quota); //unalloc_rt <-- old quota - new quota
+//            sc->sc_set_quota(new_quota);
+//            sc->get_cpu_stats()->flush();
+//        }
+////        else {
+////            std::cout << "new_quota == old_quota: " << new_quota << std::endl;
+////        }
+//    }
+////    else {
+////        std::cout << "DO NOTHING" << std::endl;
+////    }
+////    std::cout << "--------------OUT:" << req->cgroup_id << "----------------" << std::endl;
+//    cpulock.unlock();
+//    return __ALLOC_SUCCESS__;
+//
+//}
 
-}
-*/
 int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
     if(req == nullptr || res == nullptr) {
         std::cout << "req or res == null in handle_cpu_usage_report()" << std::endl;
@@ -449,6 +449,9 @@ int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
     return __ALLOC_SUCCESS__;
 
 }
+
+
+
 int ec::Manager::handle_mem_req(const ec::msg_t *req, ec::msg_t *res, int clifd) {
     if(req == nullptr || res == nullptr) {
         std::cout << "req or res == null in handle_mem_req()" << std::endl;
diff --git a/diff.txt b/diff.txt
index 148f5cf..07d63e4 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,1506 +1,197 @@
-diff --git a/Agents/AgentClient.cpp b/Agents/AgentClient.cpp
-index b739fd0..c01914d 100644
---- a/Agents/AgentClient.cpp
-+++ b/Agents/AgentClient.cpp
-@@ -9,7 +9,6 @@ ec::AgentClient::AgentClient(const ec::Agent *_agent, int _sockfd)
- 
- }
- 
--
- int64_t ec::AgentClient::send_request(const struct msg_struct::ECMessage &msg) const {
-     int status;
-     int64_t ret = -1;
-diff --git a/Agents/AgentClient.h b/Agents/AgentClient.h
-index 8a212fa..205421a 100644
---- a/Agents/AgentClient.h
-+++ b/Agents/AgentClient.h
-@@ -13,6 +13,7 @@
- #include "../protoBufSDK/msg.pb.h"
- #include "../protoBufSDK/include/ProtoBufFacade.h"
- 
-+
- using namespace google::protobuf::io;
- 
- 
-diff --git a/ECAPI.cpp b/ECAPI.cpp
-index c4c659d..99ca208 100644
---- a/ECAPI.cpp
-+++ b/ECAPI.cpp
-@@ -12,13 +12,12 @@
- int ec::ECAPI::create_ec(const std::string &app_name, const std::vector<std::string> &app_images, const std::vector<std::string> &pod_names, const std::string &gcm_ip) {
-     _ec = new ElasticContainer(manager_id, agent_clients);      
- 
--    /* This is the highest level of abstraction provided to the end application developer. 
-+    /* This is the highest level of abstraction provided to the end application developer.
-     Steps to create and deploy the "distributed container":
-         1. Create a Pod deployment strategy
-         2. Communicate with K8 REST API to deploy the pod on all nodes (based on default kube-scheduler)
-         3. Send a request to the specific agent on a node to call sys_connect
-     */
--
-     int pod_creation;
- 
-     int res;
-@@ -127,7 +126,6 @@ int ec::ECAPI::handle_add_cgroup_to_ec(const ec::msg_t *req, ec::msg_t *res, con
- 
-     // And so once a subcontainer is created and added to the appropriate distributed container,
-     // we can now create a map to link the container_id and cgroup_id - this is the place to do that..
--    
-     std::cout << "[dbg]: Init. Added cgroup to _ec with id: " << _ec->get_ec_id() << ". cgroup id: " << *sc->get_c_id() << std::endl;
-     std::cout << "[dbg]: Map Size at Insert " << _ec->get_subcontainers().size() << std::endl;
- 
-@@ -141,6 +139,7 @@ int ec::ECAPI::handle_add_cgroup_to_ec(const ec::msg_t *req, ec::msg_t *res, con
-     }
-     res->request = 0; //giveback (or send back)
-     return ret;
-+
- }
- 
- void ec::ECAPI::ec_decrement_memory_available(uint64_t mem_to_reduce) {
-@@ -192,6 +191,25 @@ int64_t ec::ECAPI::set_sc_quota(ec::SubContainer *sc, uint64_t _quota) {
- 
- }
- 
-+int64_t ec::ECAPI::resize_memory_limit_in_bytes(ec::SubContainer::ContainerId container_id, uint64_t new_mem_limit) {
-+    uint64_t ret = 0;
-+    msg_struct::ECMessage msg_req;
-+    msg_req.set_req_type(6); //RESIZE_MEM_LIMIT
-+    msg_req.set_cgroup_id(container_id.cgroup_id);
-+    msg_req.set_payload_string("test");
-+    msg_req.set_rsrc_amnt(new_mem_limit);
-+
-+    auto agent = _ec->get_corres_agent(container_id);
-+
-+    if(!agent) {
-+        std::cerr << "[dbg] temp is NULL" << std::endl;
-+        std::exit(EXIT_FAILURE);
-+    }
-+    
-+    ret = agent->send_request(msg_req);
-+    return ret;
-+}
-+
- 
- 
- 
-diff --git a/ECAPI.h b/ECAPI.h
-index 5dd944a..3a28762 100644
---- a/ECAPI.h
-+++ b/ECAPI.h
-@@ -13,7 +13,6 @@
- #include <iostream>
- #include <functional> //for std::hash
- #include <string>
--
- #include "jsonSDK/include/JSONFacade.h"
- #include "deploySDK/include/DeployFacade.h"
- #include "protoBufSDK/include/ProtoBufFacade.h"
-@@ -99,13 +98,15 @@ namespace ec {
-         void ec_decrement_memory_available(uint64_t mem_to_reduce);
-         uint64_t ec_set_memory_available(uint64_t mem) { return _ec->ec_set_memory_available(mem); }
- 
-+        int64_t resize_memory_limit_in_bytes(ec::SubContainer::ContainerId container_idm, uint64_t new_mem_limit);
-+
-         /**
-          *******************************************************
-          * EVENTS
-          * ALL CPU AND MEMORY EVENTS HANDLED HERE
-          *******************************************************
-          **/
--
-+        
-         //TODO: implement these here in a class that inherits from manager
-         int handle_add_cgroup_to_ec(const msg_t *req, msg_t *res, uint32_t ip, int fd);
-         //CPU
-diff --git a/ElasticContainer.cpp b/ElasticContainer.cpp
-index b4fdef5..8a423f5 100644
---- a/ElasticContainer.cpp
-+++ b/ElasticContainer.cpp
-@@ -69,7 +69,6 @@ ec::ElasticContainer::~ElasticContainer() {
-     }
-     subcontainers.clear();
- }
--
- void ec::ElasticContainer::update_fair_cpu_share() {
-     std::cout << "update fair share. (tot_cpu, # subconts): (" << _cpu.get_total_cpu() << ", " << subcontainers.size() << ")" << std::endl;
-     fair_cpu_share = (uint64_t)(_cpu.get_total_cpu() / subcontainers.size());
-diff --git a/ElasticContainer.h b/ElasticContainer.h
-index 3d16aaf..994f09d 100644
---- a/ElasticContainer.h
-+++ b/ElasticContainer.h
-@@ -126,7 +126,6 @@ namespace ec {
-         uint32_t ec_id;
-         subcontainer_map subcontainers;
-         subcontainer_agent_map sc_agent_map;
--
-         uint64_t fair_cpu_share;
- 
-         //Passed by reference from ECAPI but owned by GCM
-diff --git a/GlobalCloudManager.cpp b/GlobalCloudManager.cpp
-index 2e77e0c..3c7059d 100644
---- a/GlobalCloudManager.cpp
-+++ b/GlobalCloudManager.cpp
-@@ -65,7 +65,6 @@ void ec::GlobalCloudManager::run(const std::string &app_name, const std::vector<
- 
-     std::thread threads[__NUM_THREADS__];
-     //app_thread_args *args;
--//    int32_t num_of_cli = 0;
- 
-     for(const auto &s : servers) {
-         if(fork() == 0) {
-diff --git a/Manager.cpp b/Manager.cpp
-index f6782a8..70b1e6c 100644
---- a/Manager.cpp
-+++ b/Manager.cpp
-@@ -5,11 +5,10 @@
- #include "Manager.h"
- 
- ec::Manager::Manager( uint32_t server_counts, ec::ip4_addr gcm_ip, uint16_t server_port, std::vector<Agent *> &agents )
--            : Server(server_counts, gcm_ip, server_port, agents)
--{
-+            : Server(server_counts, gcm_ip, server_port, agents) {
-+
-     //init server
-     initialize();
--
-     //TODO: this is temporary. should be fixed. there is no need to have 2 instance of agentClients
-     agent_clients = agent_clients_;
-     std::cout<<"[dbg] Manager constructor: agent socket file descriptor is: " << agent_clients[0]->get_socket() << std:: endl;
-@@ -30,11 +29,12 @@ void ec::Manager::start(const std::string &app_name, const std::vector<std::stri
- }
- 
- int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
-+
-     if(req == nullptr || res == nullptr) {
-         std::cout << "req or res == null in handle_cpu_usage_report()" << std::endl;
-         exit(EXIT_FAILURE);
-     }
--    return __ALLOC_SUCCESS__;
-+//    return __ALLOC_SUCCESS__;
-     if(req->req_type != _CPU_) { return __ALLOC_FAILED__; }
- 
-     auto t1 = std::chrono::high_resolution_clock::now();
-@@ -285,6 +285,10 @@ int ec::Manager::handle_mem_req(const ec::msg_t *req, ec::msg_t *res, int clifd)
-     std::cout << "successfully decrease remaining mem to: " << ec_get_memory_available() << std::endl;
- 
-     res->rsrc_amnt = req->rsrc_amnt + ret;   //give back "ret" pages
-+//    auto sc_id = SubContainer::ContainerId(req->cgroup_id, req->client_ip);
-+//    res->rsrc_amnt = resize_memory_limit_in_bytes(sc_id, res->rsrc_amnt);
-+
-+
-     memlock.unlock();
-     res->request = 0;       //give back
-     return __ALLOC_SUCCESS__;
-@@ -352,12 +356,16 @@ void ec::Manager::run() {
-     //ec::SubContainer::ContainerId x ;
-     std::cout << "[dbg] In Manager Run function" << std::endl;
-     std::cout << "EC Map Size: " << _ec->get_subcontainers().size() << std::endl;
-+    uint64_t new_mem = 56200;
-     while(true){
-         for(auto sc_ : _ec->get_subcontainers()){
- //            std::cout << "=================================================================================================\n";
- //            std::cout << "[READ API]: the memory limit in bytes of the container with cgroup id: " << sc_.second->get_c_id()->cgroup_id << std::endl;
- //            std::cout << " on the node with ip address: " << sc_.first.server_ip  << " is: " << get_memory_limit_in_bytes(sc_.first) << std::endl;
-             sleep(1);
-+//            std::cout << "[dbg] resize maximum memory api is called: " << resize_memory_limit_in_bytes(sc_.first, new_mem) << std::endl;
-+//            new_mem += 2000;
-+//            sleep(3);
-         }
-     }
- }
-@@ -365,4 +373,3 @@ void ec::Manager::run() {
- 
- 
- 
--
-diff --git a/Server.cpp b/Server.cpp
-index 1ac9e2c..703948e 100644
---- a/Server.cpp
-+++ b/Server.cpp
-@@ -122,6 +122,13 @@ void ec::Server::handle_client_reqs(void *args) {
-             if (write(client_fd, (const char *) &*res, sizeof(*res)) < 0) {
-                 std::cout << "[ERROR]: EC Server id: " << server_id << ". Failed writing to socket" << std::endl;
-                 break;
-+//        // req->set_ip(arguments->cliaddr->sin_addr.s_addr); //this needs to be removed eventually
-+//        auto *res = new msg_t(*req);
-+//        ret = handle_req(req, res, om::net::ip4_addr::reverse_byte_order(req->client_ip).to_uint32(), arguments->clifd);
-+//        if(ret == __ALLOC_SUCCESS__) {  //TODO: fix this.
-+//            if(write(client_fd, (const char*) &*res, sizeof(*res)) < 0) {
-+//                    std::cout << "[ERROR]: EC Server id: " << server_id << ". Failed writing to socket" << std::endl;
-+//                    break;
-             }
-         }
-         else if(ret == __ALLOC_SUCCESS__ && !res->request) {
-diff --git a/main.cpp b/main.cpp
-index 8d3db0d..a2e04fc 100644
---- a/main.cpp
-+++ b/main.cpp
-@@ -42,7 +42,7 @@ int main(int argc, char* argv[]){
-         gcm->create_server();
-     }
-     std::cout << "[dbg] num servers: " << gcm->get_servers().size() << std::endl;
--
-+    
-     gcm->run(app_name, app_images, pod_names, gcm_ip);
- 
-     delete gcm;
-diff --git a/minikube b/minikube
-new file mode 100755
-index 0000000..da34802
-Binary files /dev/null and b/minikube differ
-diff --git a/proto/CMakeLists.txt b/proto/CMakeLists.txt
-new file mode 100644
-index 0000000..42e3165
---- /dev/null
-+++ b/proto/CMakeLists.txt
-@@ -0,0 +1,5 @@
-+INCLUDE(FindProtobuf)
-+FIND_PACKAGE(Protobuf REQUIRED)
-+INCLUDE_DIRECTORIES(${PROTOBUF_INCLUDE_DIR})
-+PROTOBUF_GENERATE_CPP(PROTO_SRC PROTO_HEADER msg.proto)
-+ADD_LIBRARY(proto ${PROTO_HEADER} ${PROTO_SRC})
-\ No newline at end of file
-diff --git a/proto/libproto.a b/proto/libproto.a
-new file mode 100644
-index 0000000..1227be4
-Binary files /dev/null and b/proto/libproto.a differ
-diff --git a/proto/msg.pb.cc b/proto/msg.pb.cc
-new file mode 100644
-index 0000000..c97e87b
---- /dev/null
-+++ b/proto/msg.pb.cc
-@@ -0,0 +1,524 @@
-+// Generated by the protocol buffer compiler.  DO NOT EDIT!
-+// source: msg.proto
-+
-+#include "msg.pb.h"
-+
-+#include <algorithm>
-+
-+#include <google/protobuf/io/coded_stream.h>
-+#include <google/protobuf/extension_set.h>
-+#include <google/protobuf/wire_format_lite.h>
-+#include <google/protobuf/descriptor.h>
-+#include <google/protobuf/generated_message_reflection.h>
-+#include <google/protobuf/reflection_ops.h>
-+#include <google/protobuf/wire_format.h>
-+// @@protoc_insertion_point(includes)
-+#include <google/protobuf/port_def.inc>
-+namespace msg_struct {
-+class ECMessageDefaultTypeInternal {
-+ public:
-+  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ECMessage> _instance;
-+} _ECMessage_default_instance_;
-+}  // namespace msg_struct
-+static void InitDefaultsscc_info_ECMessage_msg_2eproto() {
-+  GOOGLE_PROTOBUF_VERIFY_VERSION;
-+
-+  {
-+    void* ptr = &::msg_struct::_ECMessage_default_instance_;
-+    new (ptr) ::msg_struct::ECMessage();
-+    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
-+  }
-+  ::msg_struct::ECMessage::InitAsDefaultInstance();
-+}
-+
-+::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ECMessage_msg_2eproto =
-+    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ECMessage_msg_2eproto}, {}};
-+
-+static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_msg_2eproto[1];
-+static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_msg_2eproto = nullptr;
-+static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_msg_2eproto = nullptr;
-+
-+const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_msg_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, _has_bits_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, _internal_metadata_),
-+  ~0u,  // no _extensions_
-+  ~0u,  // no _oneof_case_
-+  ~0u,  // no _weak_field_map_
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, client_ip_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, cgroup_id_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, req_type_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, rsrc_amnt_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, request_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, runtime_remaining_),
-+  PROTOBUF_FIELD_OFFSET(::msg_struct::ECMessage, payload_string_),
-+  0,
-+  2,
-+  3,
-+  4,
-+  5,
-+  6,
-+  1,
-+};
-+static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
-+  { 0, 12, sizeof(::msg_struct::ECMessage)},
-+};
-+
-+static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
-+  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::msg_struct::_ECMessage_default_instance_),
-+};
-+
-+const char descriptor_table_protodef_msg_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
-+  "\n\tmsg.proto\022\nmsg_struct\"\232\001\n\tECMessage\022\021\n"
-+  "\tclient_ip\030\001 \001(\t\022\021\n\tcgroup_id\030\002 \001(\005\022\020\n\010r"
-+  "eq_type\030\003 \001(\005\022\021\n\trsrc_amnt\030\004 \001(\005\022\017\n\007requ"
-+  "est\030\005 \001(\005\022\031\n\021runtime_remaining\030\006 \001(\005\022\026\n\016"
-+  "payload_string\030\020 \001(\t"
-+  ;
-+static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_msg_2eproto_deps[1] = {
-+};
-+static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_msg_2eproto_sccs[1] = {
-+  &scc_info_ECMessage_msg_2eproto.base,
-+};
-+static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_msg_2eproto_once;
-+static bool descriptor_table_msg_2eproto_initialized = false;
-+const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto = {
-+  &descriptor_table_msg_2eproto_initialized, descriptor_table_protodef_msg_2eproto, "msg.proto", 180,
-+  &descriptor_table_msg_2eproto_once, descriptor_table_msg_2eproto_sccs, descriptor_table_msg_2eproto_deps, 1, 0,
-+  schemas, file_default_instances, TableStruct_msg_2eproto::offsets,
-+  file_level_metadata_msg_2eproto, 1, file_level_enum_descriptors_msg_2eproto, file_level_service_descriptors_msg_2eproto,
-+};
-+
-+// Force running AddDescriptors() at dynamic initialization time.
-+static bool dynamic_init_dummy_msg_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_msg_2eproto)), true);
-+namespace msg_struct {
-+
-+// ===================================================================
-+
-+void ECMessage::InitAsDefaultInstance() {
-+}
-+class ECMessage::_Internal {
-+ public:
-+  using HasBits = decltype(std::declval<ECMessage>()._has_bits_);
-+  static void set_has_client_ip(HasBits* has_bits) {
-+    (*has_bits)[0] |= 1u;
-+  }
-+  static void set_has_cgroup_id(HasBits* has_bits) {
-+    (*has_bits)[0] |= 4u;
-+  }
-+  static void set_has_req_type(HasBits* has_bits) {
-+    (*has_bits)[0] |= 8u;
-+  }
-+  static void set_has_rsrc_amnt(HasBits* has_bits) {
-+    (*has_bits)[0] |= 16u;
-+  }
-+  static void set_has_request(HasBits* has_bits) {
-+    (*has_bits)[0] |= 32u;
-+  }
-+  static void set_has_runtime_remaining(HasBits* has_bits) {
-+    (*has_bits)[0] |= 64u;
-+  }
-+  static void set_has_payload_string(HasBits* has_bits) {
-+    (*has_bits)[0] |= 2u;
-+  }
-+};
-+
-+ECMessage::ECMessage()
-+  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
-+  SharedCtor();
-+  // @@protoc_insertion_point(constructor:msg_struct.ECMessage)
-+}
-+ECMessage::ECMessage(const ECMessage& from)
-+  : ::PROTOBUF_NAMESPACE_ID::Message(),
-+      _internal_metadata_(nullptr),
-+      _has_bits_(from._has_bits_) {
-+  _internal_metadata_.MergeFrom(from._internal_metadata_);
-+  client_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  if (from._internal_has_client_ip()) {
-+    client_ip_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_ip_);
-+  }
-+  payload_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  if (from._internal_has_payload_string()) {
-+    payload_string_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.payload_string_);
-+  }
-+  ::memcpy(&cgroup_id_, &from.cgroup_id_,
-+    static_cast<size_t>(reinterpret_cast<char*>(&runtime_remaining_) -
-+    reinterpret_cast<char*>(&cgroup_id_)) + sizeof(runtime_remaining_));
-+  // @@protoc_insertion_point(copy_constructor:msg_struct.ECMessage)
-+}
-+
-+void ECMessage::SharedCtor() {
-+  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ECMessage_msg_2eproto.base);
-+  client_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  payload_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  ::memset(&cgroup_id_, 0, static_cast<size_t>(
-+      reinterpret_cast<char*>(&runtime_remaining_) -
-+      reinterpret_cast<char*>(&cgroup_id_)) + sizeof(runtime_remaining_));
-+}
-+
-+ECMessage::~ECMessage() {
-+  // @@protoc_insertion_point(destructor:msg_struct.ECMessage)
-+  SharedDtor();
-+}
-+
-+void ECMessage::SharedDtor() {
-+  client_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  payload_string_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+}
-+
-+void ECMessage::SetCachedSize(int size) const {
-+  _cached_size_.Set(size);
-+}
-+const ECMessage& ECMessage::default_instance() {
-+  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ECMessage_msg_2eproto.base);
-+  return *internal_default_instance();
-+}
-+
-+
-+void ECMessage::Clear() {
-+// @@protoc_insertion_point(message_clear_start:msg_struct.ECMessage)
-+  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
-+  // Prevent compiler warnings about cached_has_bits being unused
-+  (void) cached_has_bits;
-+
-+  cached_has_bits = _has_bits_[0];
-+  if (cached_has_bits & 0x00000003u) {
-+    if (cached_has_bits & 0x00000001u) {
-+      client_ip_.ClearNonDefaultToEmptyNoArena();
-+    }
-+    if (cached_has_bits & 0x00000002u) {
-+      payload_string_.ClearNonDefaultToEmptyNoArena();
-+    }
-+  }
-+  if (cached_has_bits & 0x0000007cu) {
-+    ::memset(&cgroup_id_, 0, static_cast<size_t>(
-+        reinterpret_cast<char*>(&runtime_remaining_) -
-+        reinterpret_cast<char*>(&cgroup_id_)) + sizeof(runtime_remaining_));
-+  }
-+  _has_bits_.Clear();
-+  _internal_metadata_.Clear();
-+}
-+
-+const char* ECMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
-+#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
-+  _Internal::HasBits has_bits{};
-+  while (!ctx->Done(&ptr)) {
-+    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
-+    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
-+    CHK_(ptr);
-+    switch (tag >> 3) {
-+      // optional string client_ip = 1;
-+      case 1:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
-+          auto str = _internal_mutable_client_ip();
-+          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
-+          #ifndef NDEBUG
-+          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "msg_struct.ECMessage.client_ip");
-+          #endif  // !NDEBUG
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional int32 cgroup_id = 2;
-+      case 2:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
-+          _Internal::set_has_cgroup_id(&has_bits);
-+          cgroup_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional int32 req_type = 3;
-+      case 3:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
-+          _Internal::set_has_req_type(&has_bits);
-+          req_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional int32 rsrc_amnt = 4;
-+      case 4:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
-+          _Internal::set_has_rsrc_amnt(&has_bits);
-+          rsrc_amnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional int32 request = 5;
-+      case 5:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
-+          _Internal::set_has_request(&has_bits);
-+          request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional int32 runtime_remaining = 6;
-+      case 6:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
-+          _Internal::set_has_runtime_remaining(&has_bits);
-+          runtime_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      // optional string payload_string = 16;
-+      case 16:
-+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
-+          auto str = _internal_mutable_payload_string();
-+          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
-+          #ifndef NDEBUG
-+          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "msg_struct.ECMessage.payload_string");
-+          #endif  // !NDEBUG
-+          CHK_(ptr);
-+        } else goto handle_unusual;
-+        continue;
-+      default: {
-+      handle_unusual:
-+        if ((tag & 7) == 4 || tag == 0) {
-+          ctx->SetLastTag(tag);
-+          goto success;
-+        }
-+        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
-+        CHK_(ptr != nullptr);
-+        continue;
-+      }
-+    }  // switch
-+  }  // while
-+success:
-+  _has_bits_.Or(has_bits);
-+  return ptr;
-+failure:
-+  ptr = nullptr;
-+  goto success;
-+#undef CHK_
-+}
-+
-+::PROTOBUF_NAMESPACE_ID::uint8* ECMessage::_InternalSerialize(
-+    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
-+  // @@protoc_insertion_point(serialize_to_array_start:msg_struct.ECMessage)
-+  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
-+  (void) cached_has_bits;
-+
-+  cached_has_bits = _has_bits_[0];
-+  // optional string client_ip = 1;
-+  if (cached_has_bits & 0x00000001u) {
-+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
-+      this->_internal_client_ip().data(), static_cast<int>(this->_internal_client_ip().length()),
-+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
-+      "msg_struct.ECMessage.client_ip");
-+    target = stream->WriteStringMaybeAliased(
-+        1, this->_internal_client_ip(), target);
-+  }
-+
-+  // optional int32 cgroup_id = 2;
-+  if (cached_has_bits & 0x00000004u) {
-+    target = stream->EnsureSpace(target);
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_cgroup_id(), target);
-+  }
-+
-+  // optional int32 req_type = 3;
-+  if (cached_has_bits & 0x00000008u) {
-+    target = stream->EnsureSpace(target);
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_req_type(), target);
-+  }
-+
-+  // optional int32 rsrc_amnt = 4;
-+  if (cached_has_bits & 0x00000010u) {
-+    target = stream->EnsureSpace(target);
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_rsrc_amnt(), target);
-+  }
-+
-+  // optional int32 request = 5;
-+  if (cached_has_bits & 0x00000020u) {
-+    target = stream->EnsureSpace(target);
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_request(), target);
-+  }
-+
-+  // optional int32 runtime_remaining = 6;
-+  if (cached_has_bits & 0x00000040u) {
-+    target = stream->EnsureSpace(target);
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_runtime_remaining(), target);
-+  }
-+
-+  // optional string payload_string = 16;
-+  if (cached_has_bits & 0x00000002u) {
-+    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
-+      this->_internal_payload_string().data(), static_cast<int>(this->_internal_payload_string().length()),
-+      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
-+      "msg_struct.ECMessage.payload_string");
-+    target = stream->WriteStringMaybeAliased(
-+        16, this->_internal_payload_string(), target);
-+  }
-+
-+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
-+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
-+        _internal_metadata_.unknown_fields(), target, stream);
-+  }
-+  // @@protoc_insertion_point(serialize_to_array_end:msg_struct.ECMessage)
-+  return target;
-+}
-+
-+size_t ECMessage::ByteSizeLong() const {
-+// @@protoc_insertion_point(message_byte_size_start:msg_struct.ECMessage)
-+  size_t total_size = 0;
-+
-+  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
-+  // Prevent compiler warnings about cached_has_bits being unused
-+  (void) cached_has_bits;
-+
-+  cached_has_bits = _has_bits_[0];
-+  if (cached_has_bits & 0x0000007fu) {
-+    // optional string client_ip = 1;
-+    if (cached_has_bits & 0x00000001u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
-+          this->_internal_client_ip());
-+    }
-+
-+    // optional string payload_string = 16;
-+    if (cached_has_bits & 0x00000002u) {
-+      total_size += 2 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
-+          this->_internal_payload_string());
-+    }
-+
-+    // optional int32 cgroup_id = 2;
-+    if (cached_has_bits & 0x00000004u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
-+          this->_internal_cgroup_id());
-+    }
-+
-+    // optional int32 req_type = 3;
-+    if (cached_has_bits & 0x00000008u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
-+          this->_internal_req_type());
-+    }
-+
-+    // optional int32 rsrc_amnt = 4;
-+    if (cached_has_bits & 0x00000010u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
-+          this->_internal_rsrc_amnt());
-+    }
-+
-+    // optional int32 request = 5;
-+    if (cached_has_bits & 0x00000020u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
-+          this->_internal_request());
-+    }
-+
-+    // optional int32 runtime_remaining = 6;
-+    if (cached_has_bits & 0x00000040u) {
-+      total_size += 1 +
-+        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
-+          this->_internal_runtime_remaining());
-+    }
-+
-+  }
-+  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
-+    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
-+        _internal_metadata_, total_size, &_cached_size_);
-+  }
-+  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
-+  SetCachedSize(cached_size);
-+  return total_size;
-+}
-+
-+void ECMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
-+// @@protoc_insertion_point(generalized_merge_from_start:msg_struct.ECMessage)
-+  GOOGLE_DCHECK_NE(&from, this);
-+  const ECMessage* source =
-+      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ECMessage>(
-+          &from);
-+  if (source == nullptr) {
-+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:msg_struct.ECMessage)
-+    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
-+  } else {
-+  // @@protoc_insertion_point(generalized_merge_from_cast_success:msg_struct.ECMessage)
-+    MergeFrom(*source);
-+  }
-+}
-+
-+void ECMessage::MergeFrom(const ECMessage& from) {
-+// @@protoc_insertion_point(class_specific_merge_from_start:msg_struct.ECMessage)
-+  GOOGLE_DCHECK_NE(&from, this);
-+  _internal_metadata_.MergeFrom(from._internal_metadata_);
-+  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
-+  (void) cached_has_bits;
-+
-+  cached_has_bits = from._has_bits_[0];
-+  if (cached_has_bits & 0x0000007fu) {
-+    if (cached_has_bits & 0x00000001u) {
-+      _has_bits_[0] |= 0x00000001u;
-+      client_ip_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_ip_);
-+    }
-+    if (cached_has_bits & 0x00000002u) {
-+      _has_bits_[0] |= 0x00000002u;
-+      payload_string_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.payload_string_);
-+    }
-+    if (cached_has_bits & 0x00000004u) {
-+      cgroup_id_ = from.cgroup_id_;
-+    }
-+    if (cached_has_bits & 0x00000008u) {
-+      req_type_ = from.req_type_;
-+    }
-+    if (cached_has_bits & 0x00000010u) {
-+      rsrc_amnt_ = from.rsrc_amnt_;
-+    }
-+    if (cached_has_bits & 0x00000020u) {
-+      request_ = from.request_;
-+    }
-+    if (cached_has_bits & 0x00000040u) {
-+      runtime_remaining_ = from.runtime_remaining_;
-+    }
-+    _has_bits_[0] |= cached_has_bits;
-+  }
-+}
-+
-+void ECMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
-+// @@protoc_insertion_point(generalized_copy_from_start:msg_struct.ECMessage)
-+  if (&from == this) return;
-+  Clear();
-+  MergeFrom(from);
-+}
-+
-+void ECMessage::CopyFrom(const ECMessage& from) {
-+// @@protoc_insertion_point(class_specific_copy_from_start:msg_struct.ECMessage)
-+  if (&from == this) return;
-+  Clear();
-+  MergeFrom(from);
-+}
-+
-+bool ECMessage::IsInitialized() const {
-+  return true;
-+}
-+
-+void ECMessage::InternalSwap(ECMessage* other) {
-+  using std::swap;
-+  _internal_metadata_.Swap(&other->_internal_metadata_);
-+  swap(_has_bits_[0], other->_has_bits_[0]);
-+  client_ip_.Swap(&other->client_ip_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
-+    GetArenaNoVirtual());
-+  payload_string_.Swap(&other->payload_string_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
-+    GetArenaNoVirtual());
-+  swap(cgroup_id_, other->cgroup_id_);
-+  swap(req_type_, other->req_type_);
-+  swap(rsrc_amnt_, other->rsrc_amnt_);
-+  swap(request_, other->request_);
-+  swap(runtime_remaining_, other->runtime_remaining_);
-+}
-+
-+::PROTOBUF_NAMESPACE_ID::Metadata ECMessage::GetMetadata() const {
-+  return GetMetadataStatic();
-+}
-+
-+
-+// @@protoc_insertion_point(namespace_scope)
-+}  // namespace msg_struct
-+PROTOBUF_NAMESPACE_OPEN
-+template<> PROTOBUF_NOINLINE ::msg_struct::ECMessage* Arena::CreateMaybeMessage< ::msg_struct::ECMessage >(Arena* arena) {
-+  return Arena::CreateInternal< ::msg_struct::ECMessage >(arena);
-+}
-+PROTOBUF_NAMESPACE_CLOSE
-+
-+// @@protoc_insertion_point(global_scope)
-+#include <google/protobuf/port_undef.inc>
-diff --git a/proto/msg.pb.h b/proto/msg.pb.h
-new file mode 100644
-index 0000000..1bb30bc
---- /dev/null
-+++ b/proto/msg.pb.h
-@@ -0,0 +1,615 @@
-+// Generated by the protocol buffer compiler.  DO NOT EDIT!
-+// source: msg.proto
-+
-+#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
-+#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
-+
-+#include <limits>
-+#include <string>
-+
-+#include <google/protobuf/port_def.inc>
-+#if PROTOBUF_VERSION < 3011000
-+#error This file was generated by a newer version of protoc which is
-+#error incompatible with your Protocol Buffer headers. Please update
-+#error your headers.
-+#endif
-+#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
-+#error This file was generated by an older version of protoc which is
-+#error incompatible with your Protocol Buffer headers. Please
-+#error regenerate this file with a newer version of protoc.
-+#endif
-+
-+#include <google/protobuf/port_undef.inc>
-+#include <google/protobuf/io/coded_stream.h>
-+#include <google/protobuf/arena.h>
-+#include <google/protobuf/arenastring.h>
-+#include <google/protobuf/generated_message_table_driven.h>
-+#include <google/protobuf/generated_message_util.h>
-+#include <google/protobuf/inlined_string_field.h>
-+#include <google/protobuf/metadata.h>
-+#include <google/protobuf/generated_message_reflection.h>
-+#include <google/protobuf/message.h>
-+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
-+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
-+#include <google/protobuf/unknown_field_set.h>
-+// @@protoc_insertion_point(includes)
-+#include <google/protobuf/port_def.inc>
-+#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto
-+PROTOBUF_NAMESPACE_OPEN
-+namespace internal {
-+class AnyMetadata;
-+}  // namespace internal
-+PROTOBUF_NAMESPACE_CLOSE
-+
-+// Internal implementation detail -- do not use these members.
-+struct TableStruct_msg_2eproto {
-+  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
-+    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-+  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
-+    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-+  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
-+    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-+  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
-+  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
-+  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
-+};
-+extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto;
-+namespace msg_struct {
-+class ECMessage;
-+class ECMessageDefaultTypeInternal;
-+extern ECMessageDefaultTypeInternal _ECMessage_default_instance_;
-+}  // namespace msg_struct
-+PROTOBUF_NAMESPACE_OPEN
-+template<> ::msg_struct::ECMessage* Arena::CreateMaybeMessage<::msg_struct::ECMessage>(Arena*);
-+PROTOBUF_NAMESPACE_CLOSE
-+namespace msg_struct {
-+
-+// ===================================================================
-+
-+class ECMessage :
-+    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg_struct.ECMessage) */ {
-+ public:
-+  ECMessage();
-+  virtual ~ECMessage();
-+
-+  ECMessage(const ECMessage& from);
-+  ECMessage(ECMessage&& from) noexcept
-+    : ECMessage() {
-+    *this = ::std::move(from);
-+  }
-+
-+  inline ECMessage& operator=(const ECMessage& from) {
-+    CopyFrom(from);
-+    return *this;
-+  }
-+  inline ECMessage& operator=(ECMessage&& from) noexcept {
-+    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
-+      if (this != &from) InternalSwap(&from);
-+    } else {
-+      CopyFrom(from);
-+    }
-+    return *this;
-+  }
-+
-+  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
-+    return _internal_metadata_.unknown_fields();
-+  }
-+  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
-+    return _internal_metadata_.mutable_unknown_fields();
-+  }
-+
-+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
-+    return GetDescriptor();
-+  }
-+  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
-+    return GetMetadataStatic().descriptor;
-+  }
-+  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
-+    return GetMetadataStatic().reflection;
-+  }
-+  static const ECMessage& default_instance();
-+
-+  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
-+  static inline const ECMessage* internal_default_instance() {
-+    return reinterpret_cast<const ECMessage*>(
-+               &_ECMessage_default_instance_);
-+  }
-+  static constexpr int kIndexInFileMessages =
-+    0;
-+
-+  friend void swap(ECMessage& a, ECMessage& b) {
-+    a.Swap(&b);
-+  }
-+  inline void Swap(ECMessage* other) {
-+    if (other == this) return;
-+    InternalSwap(other);
-+  }
-+
-+  // implements Message ----------------------------------------------
-+
-+  inline ECMessage* New() const final {
-+    return CreateMaybeMessage<ECMessage>(nullptr);
-+  }
-+
-+  ECMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
-+    return CreateMaybeMessage<ECMessage>(arena);
-+  }
-+  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
-+  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
-+  void CopyFrom(const ECMessage& from);
-+  void MergeFrom(const ECMessage& from);
-+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
-+  bool IsInitialized() const final;
-+
-+  size_t ByteSizeLong() const final;
-+  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
-+  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
-+      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
-+  int GetCachedSize() const final { return _cached_size_.Get(); }
-+
-+  private:
-+  inline void SharedCtor();
-+  inline void SharedDtor();
-+  void SetCachedSize(int size) const final;
-+  void InternalSwap(ECMessage* other);
-+  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
-+  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
-+    return "msg_struct.ECMessage";
-+  }
-+  private:
-+  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
-+    return nullptr;
-+  }
-+  inline void* MaybeArenaPtr() const {
-+    return nullptr;
-+  }
-+  public:
-+
-+  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
-+  private:
-+  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
-+    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_msg_2eproto);
-+    return ::descriptor_table_msg_2eproto.file_level_metadata[kIndexInFileMessages];
-+  }
-+
-+  public:
-+
-+  // nested types ----------------------------------------------------
-+
-+  // accessors -------------------------------------------------------
-+
-+  enum : int {
-+    kClientIpFieldNumber = 1,
-+    kPayloadStringFieldNumber = 16,
-+    kCgroupIdFieldNumber = 2,
-+    kReqTypeFieldNumber = 3,
-+    kRsrcAmntFieldNumber = 4,
-+    kRequestFieldNumber = 5,
-+    kRuntimeRemainingFieldNumber = 6,
-+  };
-+  // optional string client_ip = 1;
-+  bool has_client_ip() const;
-+  private:
-+  bool _internal_has_client_ip() const;
-+  public:
-+  void clear_client_ip();
-+  const std::string& client_ip() const;
-+  void set_client_ip(const std::string& value);
-+  void set_client_ip(std::string&& value);
-+  void set_client_ip(const char* value);
-+  void set_client_ip(const char* value, size_t size);
-+  std::string* mutable_client_ip();
-+  std::string* release_client_ip();
-+  void set_allocated_client_ip(std::string* client_ip);
-+  private:
-+  const std::string& _internal_client_ip() const;
-+  void _internal_set_client_ip(const std::string& value);
-+  std::string* _internal_mutable_client_ip();
-+  public:
-+
-+  // optional string payload_string = 16;
-+  bool has_payload_string() const;
-+  private:
-+  bool _internal_has_payload_string() const;
-+  public:
-+  void clear_payload_string();
-+  const std::string& payload_string() const;
-+  void set_payload_string(const std::string& value);
-+  void set_payload_string(std::string&& value);
-+  void set_payload_string(const char* value);
-+  void set_payload_string(const char* value, size_t size);
-+  std::string* mutable_payload_string();
-+  std::string* release_payload_string();
-+  void set_allocated_payload_string(std::string* payload_string);
-+  private:
-+  const std::string& _internal_payload_string() const;
-+  void _internal_set_payload_string(const std::string& value);
-+  std::string* _internal_mutable_payload_string();
-+  public:
-+
-+  // optional int32 cgroup_id = 2;
-+  bool has_cgroup_id() const;
-+  private:
-+  bool _internal_has_cgroup_id() const;
-+  public:
-+  void clear_cgroup_id();
-+  ::PROTOBUF_NAMESPACE_ID::int32 cgroup_id() const;
-+  void set_cgroup_id(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  private:
-+  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cgroup_id() const;
-+  void _internal_set_cgroup_id(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  public:
-+
-+  // optional int32 req_type = 3;
-+  bool has_req_type() const;
-+  private:
-+  bool _internal_has_req_type() const;
-+  public:
-+  void clear_req_type();
-+  ::PROTOBUF_NAMESPACE_ID::int32 req_type() const;
-+  void set_req_type(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  private:
-+  ::PROTOBUF_NAMESPACE_ID::int32 _internal_req_type() const;
-+  void _internal_set_req_type(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  public:
-+
-+  // optional int32 rsrc_amnt = 4;
-+  bool has_rsrc_amnt() const;
-+  private:
-+  bool _internal_has_rsrc_amnt() const;
-+  public:
-+  void clear_rsrc_amnt();
-+  ::PROTOBUF_NAMESPACE_ID::int32 rsrc_amnt() const;
-+  void set_rsrc_amnt(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  private:
-+  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rsrc_amnt() const;
-+  void _internal_set_rsrc_amnt(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  public:
-+
-+  // optional int32 request = 5;
-+  bool has_request() const;
-+  private:
-+  bool _internal_has_request() const;
-+  public:
-+  void clear_request();
-+  ::PROTOBUF_NAMESPACE_ID::int32 request() const;
-+  void set_request(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  private:
-+  ::PROTOBUF_NAMESPACE_ID::int32 _internal_request() const;
-+  void _internal_set_request(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  public:
-+
-+  // optional int32 runtime_remaining = 6;
-+  bool has_runtime_remaining() const;
-+  private:
-+  bool _internal_has_runtime_remaining() const;
-+  public:
-+  void clear_runtime_remaining();
-+  ::PROTOBUF_NAMESPACE_ID::int32 runtime_remaining() const;
-+  void set_runtime_remaining(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  private:
-+  ::PROTOBUF_NAMESPACE_ID::int32 _internal_runtime_remaining() const;
-+  void _internal_set_runtime_remaining(::PROTOBUF_NAMESPACE_ID::int32 value);
-+  public:
-+
-+  // @@protoc_insertion_point(class_scope:msg_struct.ECMessage)
-+ private:
-+  class _Internal;
-+
-+  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
-+  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
-+  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
-+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_ip_;
-+  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_string_;
-+  ::PROTOBUF_NAMESPACE_ID::int32 cgroup_id_;
-+  ::PROTOBUF_NAMESPACE_ID::int32 req_type_;
-+  ::PROTOBUF_NAMESPACE_ID::int32 rsrc_amnt_;
-+  ::PROTOBUF_NAMESPACE_ID::int32 request_;
-+  ::PROTOBUF_NAMESPACE_ID::int32 runtime_remaining_;
-+  friend struct ::TableStruct_msg_2eproto;
-+};
-+// ===================================================================
-+
-+
-+// ===================================================================
-+
-+#ifdef __GNUC__
-+  #pragma GCC diagnostic push
-+  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
-+#endif  // __GNUC__
-+// ECMessage
-+
-+// optional string client_ip = 1;
-+inline bool ECMessage::_internal_has_client_ip() const {
-+  bool value = (_has_bits_[0] & 0x00000001u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_client_ip() const {
-+  return _internal_has_client_ip();
-+}
-+inline void ECMessage::clear_client_ip() {
-+  client_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  _has_bits_[0] &= ~0x00000001u;
-+}
-+inline const std::string& ECMessage::client_ip() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.client_ip)
-+  return _internal_client_ip();
-+}
-+inline void ECMessage::set_client_ip(const std::string& value) {
-+  _internal_set_client_ip(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.client_ip)
-+}
-+inline std::string* ECMessage::mutable_client_ip() {
-+  // @@protoc_insertion_point(field_mutable:msg_struct.ECMessage.client_ip)
-+  return _internal_mutable_client_ip();
-+}
-+inline const std::string& ECMessage::_internal_client_ip() const {
-+  return client_ip_.GetNoArena();
-+}
-+inline void ECMessage::_internal_set_client_ip(const std::string& value) {
-+  _has_bits_[0] |= 0x00000001u;
-+  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
-+}
-+inline void ECMessage::set_client_ip(std::string&& value) {
-+  _has_bits_[0] |= 0x00000001u;
-+  client_ip_.SetNoArena(
-+    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
-+  // @@protoc_insertion_point(field_set_rvalue:msg_struct.ECMessage.client_ip)
-+}
-+inline void ECMessage::set_client_ip(const char* value) {
-+  GOOGLE_DCHECK(value != nullptr);
-+  _has_bits_[0] |= 0x00000001u;
-+  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
-+  // @@protoc_insertion_point(field_set_char:msg_struct.ECMessage.client_ip)
-+}
-+inline void ECMessage::set_client_ip(const char* value, size_t size) {
-+  _has_bits_[0] |= 0x00000001u;
-+  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
-+      ::std::string(reinterpret_cast<const char*>(value), size));
-+  // @@protoc_insertion_point(field_set_pointer:msg_struct.ECMessage.client_ip)
-+}
-+inline std::string* ECMessage::_internal_mutable_client_ip() {
-+  _has_bits_[0] |= 0x00000001u;
-+  return client_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+}
-+inline std::string* ECMessage::release_client_ip() {
-+  // @@protoc_insertion_point(field_release:msg_struct.ECMessage.client_ip)
-+  if (!_internal_has_client_ip()) {
-+    return nullptr;
-+  }
-+  _has_bits_[0] &= ~0x00000001u;
-+  return client_ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+}
-+inline void ECMessage::set_allocated_client_ip(std::string* client_ip) {
-+  if (client_ip != nullptr) {
-+    _has_bits_[0] |= 0x00000001u;
-+  } else {
-+    _has_bits_[0] &= ~0x00000001u;
-+  }
-+  client_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_ip);
-+  // @@protoc_insertion_point(field_set_allocated:msg_struct.ECMessage.client_ip)
-+}
-+
-+// optional int32 cgroup_id = 2;
-+inline bool ECMessage::_internal_has_cgroup_id() const {
-+  bool value = (_has_bits_[0] & 0x00000004u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_cgroup_id() const {
-+  return _internal_has_cgroup_id();
-+}
-+inline void ECMessage::clear_cgroup_id() {
-+  cgroup_id_ = 0;
-+  _has_bits_[0] &= ~0x00000004u;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::_internal_cgroup_id() const {
-+  return cgroup_id_;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::cgroup_id() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.cgroup_id)
-+  return _internal_cgroup_id();
-+}
-+inline void ECMessage::_internal_set_cgroup_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _has_bits_[0] |= 0x00000004u;
-+  cgroup_id_ = value;
-+}
-+inline void ECMessage::set_cgroup_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _internal_set_cgroup_id(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.cgroup_id)
-+}
-+
-+// optional int32 req_type = 3;
-+inline bool ECMessage::_internal_has_req_type() const {
-+  bool value = (_has_bits_[0] & 0x00000008u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_req_type() const {
-+  return _internal_has_req_type();
-+}
-+inline void ECMessage::clear_req_type() {
-+  req_type_ = 0;
-+  _has_bits_[0] &= ~0x00000008u;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::_internal_req_type() const {
-+  return req_type_;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::req_type() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.req_type)
-+  return _internal_req_type();
-+}
-+inline void ECMessage::_internal_set_req_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _has_bits_[0] |= 0x00000008u;
-+  req_type_ = value;
-+}
-+inline void ECMessage::set_req_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _internal_set_req_type(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.req_type)
-+}
-+
-+// optional int32 rsrc_amnt = 4;
-+inline bool ECMessage::_internal_has_rsrc_amnt() const {
-+  bool value = (_has_bits_[0] & 0x00000010u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_rsrc_amnt() const {
-+  return _internal_has_rsrc_amnt();
-+}
-+inline void ECMessage::clear_rsrc_amnt() {
-+  rsrc_amnt_ = 0;
-+  _has_bits_[0] &= ~0x00000010u;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::_internal_rsrc_amnt() const {
-+  return rsrc_amnt_;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::rsrc_amnt() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.rsrc_amnt)
-+  return _internal_rsrc_amnt();
-+}
-+inline void ECMessage::_internal_set_rsrc_amnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _has_bits_[0] |= 0x00000010u;
-+  rsrc_amnt_ = value;
-+}
-+inline void ECMessage::set_rsrc_amnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _internal_set_rsrc_amnt(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.rsrc_amnt)
-+}
-+
-+// optional int32 request = 5;
-+inline bool ECMessage::_internal_has_request() const {
-+  bool value = (_has_bits_[0] & 0x00000020u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_request() const {
-+  return _internal_has_request();
-+}
-+inline void ECMessage::clear_request() {
-+  request_ = 0;
-+  _has_bits_[0] &= ~0x00000020u;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::_internal_request() const {
-+  return request_;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::request() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.request)
-+  return _internal_request();
-+}
-+inline void ECMessage::_internal_set_request(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _has_bits_[0] |= 0x00000020u;
-+  request_ = value;
-+}
-+inline void ECMessage::set_request(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _internal_set_request(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.request)
-+}
-+
-+// optional int32 runtime_remaining = 6;
-+inline bool ECMessage::_internal_has_runtime_remaining() const {
-+  bool value = (_has_bits_[0] & 0x00000040u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_runtime_remaining() const {
-+  return _internal_has_runtime_remaining();
-+}
-+inline void ECMessage::clear_runtime_remaining() {
-+  runtime_remaining_ = 0;
-+  _has_bits_[0] &= ~0x00000040u;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::_internal_runtime_remaining() const {
-+  return runtime_remaining_;
-+}
-+inline ::PROTOBUF_NAMESPACE_ID::int32 ECMessage::runtime_remaining() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.runtime_remaining)
-+  return _internal_runtime_remaining();
-+}
-+inline void ECMessage::_internal_set_runtime_remaining(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _has_bits_[0] |= 0x00000040u;
-+  runtime_remaining_ = value;
-+}
-+inline void ECMessage::set_runtime_remaining(::PROTOBUF_NAMESPACE_ID::int32 value) {
-+  _internal_set_runtime_remaining(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.runtime_remaining)
-+}
-+
-+// optional string payload_string = 16;
-+inline bool ECMessage::_internal_has_payload_string() const {
-+  bool value = (_has_bits_[0] & 0x00000002u) != 0;
-+  return value;
-+}
-+inline bool ECMessage::has_payload_string() const {
-+  return _internal_has_payload_string();
-+}
-+inline void ECMessage::clear_payload_string() {
-+  payload_string_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+  _has_bits_[0] &= ~0x00000002u;
-+}
-+inline const std::string& ECMessage::payload_string() const {
-+  // @@protoc_insertion_point(field_get:msg_struct.ECMessage.payload_string)
-+  return _internal_payload_string();
-+}
-+inline void ECMessage::set_payload_string(const std::string& value) {
-+  _internal_set_payload_string(value);
-+  // @@protoc_insertion_point(field_set:msg_struct.ECMessage.payload_string)
-+}
-+inline std::string* ECMessage::mutable_payload_string() {
-+  // @@protoc_insertion_point(field_mutable:msg_struct.ECMessage.payload_string)
-+  return _internal_mutable_payload_string();
-+}
-+inline const std::string& ECMessage::_internal_payload_string() const {
-+  return payload_string_.GetNoArena();
-+}
-+inline void ECMessage::_internal_set_payload_string(const std::string& value) {
-+  _has_bits_[0] |= 0x00000002u;
-+  payload_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
-+}
-+inline void ECMessage::set_payload_string(std::string&& value) {
-+  _has_bits_[0] |= 0x00000002u;
-+  payload_string_.SetNoArena(
-+    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
-+  // @@protoc_insertion_point(field_set_rvalue:msg_struct.ECMessage.payload_string)
-+}
-+inline void ECMessage::set_payload_string(const char* value) {
-+  GOOGLE_DCHECK(value != nullptr);
-+  _has_bits_[0] |= 0x00000002u;
-+  payload_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
-+  // @@protoc_insertion_point(field_set_char:msg_struct.ECMessage.payload_string)
-+}
-+inline void ECMessage::set_payload_string(const char* value, size_t size) {
-+  _has_bits_[0] |= 0x00000002u;
-+  payload_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
-+      ::std::string(reinterpret_cast<const char*>(value), size));
-+  // @@protoc_insertion_point(field_set_pointer:msg_struct.ECMessage.payload_string)
-+}
-+inline std::string* ECMessage::_internal_mutable_payload_string() {
-+  _has_bits_[0] |= 0x00000002u;
-+  return payload_string_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+}
-+inline std::string* ECMessage::release_payload_string() {
-+  // @@protoc_insertion_point(field_release:msg_struct.ECMessage.payload_string)
-+  if (!_internal_has_payload_string()) {
-+    return nullptr;
-+  }
-+  _has_bits_[0] &= ~0x00000002u;
-+  return payload_string_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
-+}
-+inline void ECMessage::set_allocated_payload_string(std::string* payload_string) {
-+  if (payload_string != nullptr) {
-+    _has_bits_[0] |= 0x00000002u;
-+  } else {
-+    _has_bits_[0] &= ~0x00000002u;
-+  }
-+  payload_string_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload_string);
-+  // @@protoc_insertion_point(field_set_allocated:msg_struct.ECMessage.payload_string)
-+}
-+
-+#ifdef __GNUC__
-+  #pragma GCC diagnostic pop
-+#endif  // __GNUC__
-+
-+// @@protoc_insertion_point(namespace_scope)
-+
-+}  // namespace msg_struct
-+
-+// @@protoc_insertion_point(global_scope)
-+
-+#include <google/protobuf/port_undef.inc>
-+#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
-diff --git a/proto/msg.proto b/proto/msg.proto
-new file mode 100644
-index 0000000..0bbec12
---- /dev/null
-+++ b/proto/msg.proto
-@@ -0,0 +1,12 @@
-+syntax = "proto2";
-+package msg_struct;
-+
-+message ECMessage {
-+    optional string client_ip = 1;
-+    optional int32 cgroup_id = 2;
-+    optional int32 req_type = 3;
-+    optional int32 rsrc_amnt = 4;
-+    optional int32 request = 5;
-+    optional int32 runtime_remaining = 6; 
-+    optional string payload_string = 16;
-+}
-\ No newline at end of file
-diff --git a/tests/app_def.json b/tests/app_def.json
-index b2b35d6..61e20b7 100644
---- a/tests/app_def.json
-+++ b/tests/app_def.json
-@@ -11,8 +11,8 @@
- 		"10.0.2.15"
- 	],
- 	"images": [
--		"gregcusack/flask-app:abh1-v2",
--		"gregcusack/flask-app:abh2-v2"
-+		"gregcusack/flask-app:absat-1",
-+		"gregcusack/flask-app:absat-2"
- 	],
- 	"pod-names": [
- 		"f-1",
-diff --git a/types/msg.cpp b/types/msg.cpp
-index 225544a..5c20d11 100644
---- a/types/msg.cpp
-+++ b/types/msg.cpp
-@@ -5,14 +5,6 @@
- 
- #include "msg.h"
- 
--ec::msg_t::msg_t(const ec::k_msg_t &k_msg) {
--    client_ip = om::net::ip4_addr::from_host(k_msg.client_ip);
--    cgroup_id = k_msg.cgroup_id;
--    req_type = k_msg.req_type;
--    rsrc_amnt = k_msg.rsrc_amnt;
--    request = k_msg.request;
--}
--
- ec::msg_t::msg_t(const ec::msg_t &msg_req) {
-     client_ip = msg_req.client_ip;
-     cgroup_id = msg_req.cgroup_id;
-@@ -20,5 +12,5 @@ ec::msg_t::msg_t(const ec::msg_t &msg_req) {
-     rsrc_amnt = msg_req.rsrc_amnt;
-     request = msg_req.request;
-     runtime_remaining = msg_req.runtime_remaining;
--    cont_name = msg_req.cont_name;
-+//    cont_name = msg_req.cont_name;
- }
-diff --git a/types/msg.h b/types/msg.h
-index 7693be1..18c0524 100644
---- a/types/msg.h
-+++ b/types/msg.h
-@@ -9,7 +9,6 @@
- #include <iostream>
- #include <cstdlib>
- #include "../om.h"
--#include "k_msg.h"
- 
- namespace ec {
-     struct msg_t {
-@@ -18,7 +17,6 @@ namespace ec {
-         msg_t& operator=(const msg_t&)              = default;
-         msg_t(msg_t&&)                              = default;
-         msg_t& operator=(msg_t&&)                   = default;
--        explicit msg_t(const ec::k_msg_t& k_msg);
- 
-         om::net::ip4_addr   client_ip;      //ip SubContainer sending message is on
-         uint32_t            cgroup_id;      //id of SubContainer on that Server
-@@ -26,7 +24,7 @@ namespace ec {
-         uint64_t            rsrc_amnt;      //amount of resources (cpu/mem)
-         uint32_t                request;        //1: request, 0: give back
-         uint64_t            runtime_remaining;
--        uint64_t            cont_name;
-+//        uint64_t            cont_name;
- 
-         friend std::ostream& operator<<(std::ostream& os_, const msg_t& k) {
-             return os_ << "msg_t: "
+int ec::Manager::handle_cpu_usage_report(const ec::msg_t *req, ec::msg_t *res) {
+    if(req == nullptr || res == nullptr) {
+        std::cout << "req or res == null in handle_cpu_usage_report()" << std::endl;
+        exit(EXIT_FAILURE);
+    }
+//    std::mutex cpulock;
+    if(req->req_type != _CPU_) { return __ALLOC_FAILED__; }
+
+    auto t1 = std::chrono::high_resolution_clock::now();
+    cpulock.lock();
+//    std::cout << "------------------------------" << std::endl;
+//    std::cout << "cg id: " << req->cgroup_id << std::endl;
+    auto sc_id = SubContainer::ContainerId(req->cgroup_id, req->client_ip);
+    auto sc = ec_get_sc_for_update(sc_id);
+    if(!sc) {
+        std::cout << "ERROR! sc is NULL!" << std::endl;
+        return __ALLOC_SUCCESS__;
+    }
+    sc->incr_counter();
+    auto req_count = sc->get_counter();
+    auto rx_quota = req->rsrc_amnt;
+    auto rt_remaining = req->runtime_remaining;
+    auto throttled = req->request;
+    uint64_t updated_quota = rx_quota;
+    uint64_t to_add = 0;
+    int ret;
+    uint64_t rx_buff;
+    double thr_mean = 0;
+    uint64_t rt_mean = 0;
+    uint64_t total_rt = 0;
+
+    for(const auto &i : get_subcontainers()) {
+        total_rt += i.second->sc_get_quota();
+    }
+    total_rt += ec_get_cpu_unallocated_rt();
+//    std::cout << "total rt: " << total_rt << std::endl;
+//    if(ec_get_fair_cpu_share() * get_subcontainers().size() < total_rt) {
+//        std::cout << "WOOPS! ALLOC TOO MUCH CPU!" << std::endl;
+//    }
+
+//    std::cout << "quota, rt_remaining, throttled): (" << rx_quota << ", " << rt_remaining << ", " << throttled << ")" << std::endl;
+//    //TODO: when we change quota, we need to flush the window
+//    if(likely(!sc->get_set_quota_flag())) {
+//        rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
+//        thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
+//    } else {
+//        rt_mean = sc->get_cpu_stats()->get_rt_mean();
+//        thr_mean = sc->get_cpu_stats()->get_thr_mean();
+//        sc->set_quota_flag(false);
+//    }
+    rt_mean = sc->get_cpu_stats()->insert_rt_stats(rt_remaining);
+    thr_mean = sc->get_cpu_stats()->insert_th_stats(throttled);
+//    std::cout << "rt_mean: " << rt_mean << std::endl;
+//    std::cout << "thr_mean: " << thr_mean << std::endl;
+    std::cout << "cpu_unalloc: " << ec_get_cpu_unallocated_rt() << std::endl;
+
+    if(ec_get_overrun() > 0 && rx_quota > ec_get_fair_cpu_share()) {
+//        std::cout << "overrun. sc: " << *sc->get_c_id() << std::endl;
+        uint64_t to_sub;
+        uint64_t amnt_share_over = rx_quota - ec_get_fair_cpu_share();
+        uint64_t overrun = ec_get_overrun();
+        double percent_over = ((double)rx_quota - (double)ec_get_fair_cpu_share()) / (double)ec_get_fair_cpu_share();
+//        std::cout << "percent over: " << percent_over << std::endl;
+        if(percent_over > 1) {
+            to_sub = (uint64_t) (percent_over * (double) ec_get_cpu_slice());
+        }
+        else {
+            to_sub = (uint64_t) (percent_over * (double)amnt_share_over);
+        }
+        //TODO: thr_mean is probably important. Take less from containers that are constantly being throttled
+//        uint64_t to_sub_frac = (1 - thr_mean) * amnt_share_over;
+        if(to_sub < ec_get_cpu_slice() / 2) { //ensures we eventually converge
+            to_sub = amnt_share_over;
+        }
+        to_sub = std::min(overrun, to_sub);
+        updated_quota = rx_quota - to_sub;
+        ret = set_sc_quota(sc, updated_quota);
+        if(ret < 0) {
+            std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (overrun sub quota). ret: " << ret << std::endl;
+        }
+        else {
+            sc->set_quota_flag(true);
+            std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
+        }
+        sc->get_cpu_stats()->flush();
+        ec_decr_overrun(to_sub);
+        sc->sc_set_quota(updated_quota);
+    }
+    else if(rx_quota < ec_get_fair_cpu_share() && thr_mean > 0.5) {   //throttled but don't have fair share
+//        std::cout << "throt and less than fair share. sc: " << *sc->get_c_id() << std::endl;
+        uint64_t amnt_share_lacking = ec_get_fair_cpu_share() - rx_quota;
+//        std::cout << "amnt_share_lacking: " << amnt_share_lacking << std::endl;
+        if (ec_get_cpu_unallocated_rt() > 0) {
+            //TODO: take min of to_Add and slice. don't full reset
+//            std::cout << "give back some unalloc_Rt. sc: " << *sc->get_c_id() << std::endl;
+            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
+            std::cout << "percent under1: " << percent_under << std::endl;
+            if(amnt_share_lacking > ec_get_cpu_slice() / 2) {   //ensure we eventually converge
+                to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(percent_under * (double)amnt_share_lacking));
+            }
+            else {
+                to_add = amnt_share_lacking;
+            }
+//            to_add = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(thr_mean * amnt_share_lacking));
+//            std::cout << "to_Add: " << to_add << std::endl;
+            updated_quota = rx_quota + to_add;
+            ret = set_sc_quota(sc, updated_quota);
+            if(ret < 0) {
+                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share). ret: " << ret << std::endl;
+            }
+            else {
+                sc->set_quota_flag(true);
+                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
+            }
+            ec_decr_unallocated_rt(to_add);
+            sc->sc_set_quota(updated_quota);
+//            std::cout << "new_quota: " << updated_quota << std::endl;
+//            std::cout << "ec_get_unalloc_rt: " << ec_get_cpu_unallocated_rt() << std::endl;
+        }
+        else { //not enough in unalloc_rt to get back to fair share, even out
+//            std::cout << "not enough in unalloc rt. give back slice or overrun.. sc: " << *sc->get_c_id() << std::endl;
+            uint64_t overrun;
+            double percent_under = ((double)ec_get_fair_cpu_share() - (double)rx_quota) / (double)ec_get_fair_cpu_share();
+//            std::cout << "percent under2: " << percent_under << std::endl;
+//            overrun = (uint64_t)thr_mean * amnt_share_lacking;
+            if(amnt_share_lacking > ec_get_cpu_slice() / 2) { //ensure we eventualyl converge
+                overrun = (uint64_t)((double) percent_under * amnt_share_lacking);
+            }
+            else {
+                overrun = amnt_share_lacking;
+            }
+            updated_quota = rx_quota + overrun;
+            ret = set_sc_quota(sc, updated_quota);
+            if(ret < 0) {
+                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr fair share overrun). ret: " << ret << std::endl;
+            }
+            else {
+                sc->set_quota_flag(true);
+                std::cout << "successfully resized quota to: " << updated_quota << "!" << std::endl;
+            }
+            ec_incr_overrun(overrun);
+            sc->sc_set_quota(updated_quota);
+        }
+        sc->get_cpu_stats()->flush();
+    }
+    else if(thr_mean >= 0.2 && ec_get_cpu_unallocated_rt() > 0) {  //sc_quota > fair share and container got throttled during the last period. need rt
+//        std::cout << "throttle. try get alloc. sc:  " << *sc->get_c_id() << std::endl;
+        auto extra_rt = std::min(ec_get_cpu_unallocated_rt(), (uint64_t)(2 * thr_mean * ec_get_cpu_slice()));
+        std::cout << "extra_rt: " << extra_rt << std::endl;
+        if(extra_rt > 0) {
+            ec_decr_unallocated_rt(extra_rt);
+            updated_quota = rx_quota + extra_rt;
+            ret = set_sc_quota(sc, updated_quota);
+            if(ret < 0) {
+                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (incr). ret: " << ret << std::endl;
+            }
+            else {
+                sc->set_quota_flag(true);
+                std::cout << "successfully resized quota to: " << rx_quota + extra_rt << "!" << std::endl;
+            }
+        }
+//        else {
+//            std::cout << "extra_rt == 0: " << extra_rt << std::endl;
+//        }
+        sc->sc_set_quota(updated_quota);
+        sc->get_cpu_stats()->flush();
+    }
+    else if(rt_mean > rx_quota * 0.2) { //greater than 20% of quota unused
+//        std::cout << "rt_mean > 20% of quota. sc: " << *sc->get_c_id() << std::endl;
+        uint64_t new_quota = rx_quota * (1 - 0.2); //sc_quota - sc_rt_remaining + ec_get_cpu_slice();
+        new_quota = std::max(ec_get_cpu_slice(), new_quota);
+        if(new_quota != rx_quota) {
+//            std::cout << "new, old, rt_remain: (" << new_quota << "," << rx_quota << "," << rt_mean << ")" << std::endl;
+            ret = set_sc_quota(sc, new_quota); //give back what was used + 5ms
+            if(ret < 0) {
+                std::cout << "[ERROR]: GCM. Can't read from socket to resize quota (decr). ret: " << ret << std::endl;
+            }
+            else {
+                sc->set_quota_flag(true);
+                std::cout << "successfully resized quota to: " << new_quota << "!" << std::endl;
+            }
+//            std::cout << "old quota, new quota: (" << rx_quota << ", " << new_quota << ")" << std::endl;
+            ec_incr_unallocated_rt(rx_quota - new_quota); //unalloc_rt <-- old quota - new quota
+            sc->sc_set_quota(new_quota);
+            sc->get_cpu_stats()->flush();
+        }
+//        else {
+//            std::cout << "new_quota == old_quota: " << new_quota << std::endl;
+//        }
+    }
+//    else {
+//        std::cout << "DO NOTHING" << std::endl;
+//    }
+
+    return __ALLOC_SUCCESS__;
+
+}
diff --git a/tests/app_def.json b/tests/app_def.json
index 61e20b7..4bfafb1 100644
--- a/tests/app_def.json
+++ b/tests/app_def.json
@@ -11,8 +11,8 @@
 		"10.0.2.15"
 	],
 	"images": [
-		"gregcusack/flask-app:absat-1",
-		"gregcusack/flask-app:absat-2"
+		"gregcusack/ec-sat:b_sat",
+		"gregcusack/ec-sat:b_dyn"
 	],
 	"pod-names": [
 		"f-1",
